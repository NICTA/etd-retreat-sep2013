module Answers where

import Data.Char(intToDigit, toLower)
import Data.Function(on)
import Data.List(foldl', find, isPrefixOf)
import Data.Maybe(maybe, fromMaybe, mapMaybe)
import Data.MemoCombinators(memo2, integral)
import Control.Applicative((<*>), liftA2)
import Control.Monad(join)
import Numeric(showIntAtBase)

-- | A palindromic number reads the same both ways. The largest palindrome made from 
-- the product of two 2-digit numbers is 9009 = 91 × 99.
--
-- Print the largest palindrome made from the product of two 4-digit numbers.
exercise1 =
  let four = [9999, 9998..1000]
      isPalindrome = ((==) =<< reverse) . show
  in maybe "lol" show . find isPalindrome $ liftA2 (*) four four

-- | 2520 is the smallest number that can be divided by each of the numbers from
-- 1 to 10 without any remainder.
--
-- Given an integer between 1 and 50 on the input (n), print the smallest
-- positive number that is evenly divisible by all of the numbers from 1 to n.
--
-- >>> exercise2 7
-- 420
--
-- >>> exercise2 15
-- 360360
--
-- >>> exercise2 10
-- 2520
exercise2 ::
  Integral a =>
  a
  -> a
exercise2 n =
  foldl' lcm 1 [2..n]

-- | Encode a URL such that special characters are replaced by a given string of
-- characters. The encoding rules are as follows:
--
--     '+' -> "%2B"
--     ' ' -> "%20"
--     '#' -> "%23"
--     '%' -> "%25"
--
-- All other characters remain unchanged.
--
-- >>> exercise3 "http://google.com/"
-- "http://google.com/"
--
-- >>> exercise3 "http://google.com/?a b"
-- "http://google.com/?a%20b"
--
-- >>> exercise3 "http://google.com/?a b&x=#y"
-- "http://google.com/?a%20b&x=%23y"
--
-- >>> exercise3 "http://google.com/?a b&x=#y&%+f=g%"
-- "http://google.com/?a%20b&x=%23y&%25%2Bf=g%25"
exercise3 ::
  String
  -> String
exercise3 =
  concatMap $ \c -> case c of '+' -> "%2B"
                              ' ' -> "%20"
                              '#' -> "%23"
                              '%' -> "%25"
                              _   -> [c]

-- | The sum of the squares of the first ten natural numbers is,
-- 1² + 2² + ... + 10² = 385
--
-- The square of the sum of the first ten natural numbers is,
-- (1 + 2 + ... + 10)² = 552 = 3025
--
-- Hence the difference between the sum of the squares of the first ten natural 
-- numbers and the square of the sum is 3025 − 385 = 2640.
--
-- Given an integer between 1 and 200 on the input (n), print the difference
-- between the sum of the squares of the first n natural numbers and the square 
-- of the sum.
--
-- >>> exercise4 10
-- 2640
--
-- >>> exercise4 100
-- 25164150
--
-- >>> exercise4 120
-- 52124380
exercise4 ::
  Integral a =>
  a
  -> a
exercise4 n =
  let square = join (*)
      sumS = foldl' (\a b -> a + square b) 0 [1..n]
      squareS = square (triangle n)
  in squareS - sumS

-- | Given 1000 consecutive arbitrary digits (a digit is [0-9]) as input, print the
-- greatest product of any 5 consecutive digits of that input.
--
-- >>> exercise5 "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"
-- 40824
exercise5 :: 
  (Num a, Ord a, Read a) => 
  String
  -> a
exercise5 s = 
  let toi = map fst . reads . return
  in maximum (product . take 5 <<= (s >>= toi))

-- | The sequence of triangle numbers is generated by adding the natural 
-- numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
-- The first ten terms would be:
--
--     1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
--
-- Let us list the factors of the first seven triangle numbers:
--
--      1: 1
--      3: 1,3
--      6: 1,2,3,6
--     10: 1,2,5,10
--     15: 1,3,5,15
--     21: 1,3,7,21
--     28: 1,2,4,7,14,28
--
-- We can see that 28 is the first triangle number to have over five divisors.
--
-- Given an integer between 1 and 1000 as input (n), print the value of the
-- first triangle number to have over n divisors.
--
-- >>> exercise6 5
-- 28
--
-- >>> exercise6 12
-- 120
--
-- >>> exercise6 16
-- 300
exercise6 ::
  (Num n, Ord n) =>
  n
  -> Int
exercise6 n =
  fromMaybe 0 . lookup True . map (\q -> 
    let t = triangle q in (lengthGT n . factors $ t, t)) $ [1..]

-- | The decimal number, 585 = 1001001001₂ (binary), is palindromic in both 
-- bases.
--
-- Given an integer between 10 and 5000000 as input (n), print the sum of all 
-- positive numbers, less than n, which are palindromic in base 10 and base 2.
--
-- Note that the palindromic number, in either base, may not include leading
-- zeros.
--
-- >>> exercise7 100
-- 157
--
-- >>> exercise7 1000
-- 1772
--
-- >>> exercise7 100000
-- 286602
--
-- >>> exercise7 2000000
-- 6544940
exercise7 :: 
  (Integral a, Show a) =>
  a
  -> a
exercise7 n =
  let isPalindrome = (==) =<< reverse      
      base2 = flip (showIntAtBase 2 intToDigit) []
  in sum . filter (on (&&) isPalindrome . show <*> base2) $ [1..n]

-- | Given an odd number (3 or greater) of integers as input, call the first 
-- integer the maximum possible weight (M) and the remaining pairs of integers a 
-- list of value and associated weight of some items.
--
-- Select any items (pair of value and weight) and print the sum of their values 
-- such that the following hold:
-- 
-- * the sum of the individual values of the items is equal to, or greater than,
-- any other possible selection of items.
-- * the sum of the individual weights of the items does not exceed the maximum 
-- possible weight (M).
--
-- >>> exercise8 [(3, 2), (4, 1), (5, 3)] 3
-- 7
--
-- >>> exercise8 [(3, 2), (4, 1), (5, 3)] 4
-- 9
--
-- >>> exercise8 [(3, 2), (4, 1), (5, 3)] 5
-- 9
--
-- >>> exercise8 [(40, 100), (35, 50), (18, 45), (4, 20), (10, 10), (2, 5)] 100
-- 55
--
-- >>> exercise8 [(50, 92), (93, 79), (89, 38), (39, 5), (84, 95), (52, 49), (41, 94), (51, 19), (65, 99), (88, 6), (88, 73), (89, 63), (3, 50), (92, 93), (79, 89), (38, 39), (5, 84), (95, 52), (49, 41), (94, 51)] 100
-- 310
--
-- >>> exercise8 [(50, 92), (93, 79), (89, 38), (39, 5), (84, 95), (52, 49), (41, 94), (51, 19), (65, 99), (88, 6), (88, 73), (89, 63), (3, 50), (92, 93), (79, 89), (38, 39), (5, 84), (95, 52), (49, 41)] 100
-- 273
exercise8 ::
  (Num v, Ord v, Integral w) =>
  [(v, w)]
  -> w
  -> v
exercise8 items =
  let knapsack i =
        let matrix _ 0 = 0
            matrix 0 _ = 0
            matrix m n = let z = m - 1
                             m' = memo2 integral integral matrix z
                             (v, w) = i z
                             x | n == w = v
                               | otherwise = m' (n - w) + v
                             f | n < w = id
                               | otherwise = max x
                         in f (m' n)
            backtrack 0 _ = []
            backtrack _ 0 = []
            backtrack m n
              | matrix m n == matrix (m - 1) n = backtrack (m - 1) n
              | otherwise = i (m - 1) : backtrack (m - 1) (n - snd (i (m - 1)))
        in backtrack
  in foldl' (\x (v, _) -> v + x) 0 . knapsack (items !!) (length items)

-- | Given a string representing a numeric value of money on the input, print 
-- the verbatim transcription of that amount in English words.
--
-- For example, the input "1.11" will result in a return value of "one dollar 
-- and eleven cents". Pluralisation should be grammatically correct. For 
-- example, "1.01" produces "one dollar and one cent".
--
-- Invalid characters should be ignored, meaning that every input string has an 
-- output string. The empty string produces "zero dollars and zero cents".
--
--
-- >>> exercise9 "0"
-- "zero dollars and zero cents"
--
-- >>> exercise9 "1"
-- "one dollar and zero cents"
--
-- >>> exercise9 "0.1"
-- "zero dollars and ten cents"
--
-- >>> exercise9 "1."
-- "one dollar and zero cents"
--
-- >>> exercise9 "0."
-- "zero dollars and zero cents"
--
-- >>> exercise9 "0.0"
-- "zero dollars and zero cents"
--
-- >>> exercise9 ".34"
-- "zero dollars and thirty-four cents"
--
-- >>> exercise9 "0.3456789"
-- "zero dollars and thirty-four cents"
--
-- >>> exercise9 "1.0"
-- "one dollar and zero cents"
--
-- >>> exercise9 "1.01"
-- "one dollar and one cent"
--
-- >>> exercise9 "a1a"
-- "one dollar and zero cents"
--
-- >>> exercise9 "a1a.a0.7b"
-- "one dollar and seven cents"
--
-- >>> exercise9 "100"
-- "one hundred dollars and zero cents"
--
-- >>> exercise9 "100.0"
-- "one hundred dollars and zero cents"
--
-- >>> exercise9 "100.00"
-- "one hundred dollars and zero cents"
--
-- >>> exercise9 "100.00000"
-- "one hundred dollars and zero cents"
--
-- >>> exercise9 "1000456.13"
-- "one million four hundred and fifty-six dollars and thirteen cents"
--
-- >>> exercise9 "1001456.13"
-- "one million one thousand four hundred and fifty-six dollars and thirteen cents"
--
-- >>> exercise9 "16000000456.13"
-- "sixteen billion four hundred and fifty-six dollars and thirteen cents"
--
-- >>> exercise9 "100.45"
-- "one hundred dollars and forty-five cents"
--
-- >>> exercise9 "100.07"
-- "one hundred dollars and seven cents"
--
-- >>> exercise9 "9abc9def9ghi.jkl9mno"
-- "nine hundred and ninety-nine dollars and ninety cents"
--
-- >>> exercise9 "12345.67"
-- "twelve thousand three hundred and forty-five dollars and sixty-seven cents"
--
-- >>> exercise9 "456789123456789012345678901234567890123456789012345678901234567890.12"
-- "four hundred and fifty-six vigintillion seven hundred and eighty-nine novemdecillion one hundred and twenty-three octodecillion four hundred and fifty-six septendecillion seven hundred and eighty-nine sexdecillion twelve quindecillion three hundred and forty-five quattuordecillion six hundred and seventy-eight tredecillion nine hundred and one duodecillion two hundred and thirty-four undecillion five hundred and sixty-seven decillion eight hundred and ninety nonillion one hundred and twenty-three octillion four hundred and fifty-six septillion seven hundred and eighty-nine sextillion twelve quintillion three hundred and forty-five quadrillion six hundred and seventy-eight trillion nine hundred and one billion two hundred and thirty-four million five hundred and sixty-seven thousand eight hundred and ninety dollars and twelve cents"
exercise9 ::
  String
  -> String
exercise9 x =
  let (d, c) = toDot (dropWhile (`notElem` ('.':['1'..'9'])) x)
      c' =
        case mapMaybe fromChar c of
          [] -> "zero cents"
          [Zero, One] -> "one cent"
          (a:b:_) -> show (D2 a b) ++ " cents"
          (a:_) -> show (D2 a Zero) ++ " cents"
      d' =
        case d of
          [] -> "zero dollars"
          [One] -> "one dollar"
          _ -> illionate d ++ " dollars"
      fromChar '0' =
        Just Zero
      fromChar '1' =
        Just One
      fromChar '2' =
        Just Two
      fromChar '3' =
        Just Three
      fromChar '4' =
        Just Four
      fromChar '5' =
        Just Five
      fromChar '6' =
        Just Six
      fromChar '7' =
        Just Seven
      fromChar '8' =
        Just Eight
      fromChar '9' =
        Just Nine
      fromChar _ =
        Nothing
      illion =
        let preillion ::
              [String -> String]
            preillion =
              [
                const ""
              , const "un"
              , const "do"
              , const "tre"
              , const "quattuor"
              , const "quin"
              , const "sex"
              , const "septen"
              , const "octo"
              , \q -> if "n" `isPrefixOf` q then "novem" else "noven"
              ]
            postillion ::
              [String]
            postillion =
              [
                "vigintillion"
              , "trigintillion"
              , "quadragintillion"
              , "quinquagintillion"
              , "sexagintillion"
              , "septuagintillion"
              , "octogintillion"
              , "nonagintillion"
              , "centillion"
              , "decicentillion"
              , "viginticentillion"
              , "trigintacentillion"
              , "quadragintacentillion"
              , "quinquagintacentillion"
              , "sexagintacentillion"
              , "septuagintacentillion"
              , "octogintacentillion"
              , "nonagintacentillion"
              , "ducentillion"
              , "deciducentillion"
              , "vigintiducentillion"
              , "trigintaducentillion"
              , "quadragintaducentillion"
              , "quinquagintaducentillion"
              , "sexagintaducentillion"
              , "septuagintaducentillion"
              , "octogintaducentillion"
              , "nonagintaducentillion"
              , "trecentillion"
              , "decitrecentillion"
              , "vigintitrecentillion"
              , "trigintatrecentillion"
              , "quadragintatrecentillion"
              , "quinquagintatrecentillion"
              , "sexagintatrecentillion"
              , "septuagintatrecentillion"
              , "octogintatrecentillion"
              , "nonagintatrecentillion"
              , "quadringentillion"
              , "deciquadringentillion"
              , "vigintiquadringentillion"
              , "trigintaquadringentillion"
              , "quadragintaquadringentillion"
              , "quinquagintaquadringentillion"
              , "sexagintaquadringentillion"
              , "septuagintaquadringentillion"
              , "octogintaquadringentillion"
              , "nonagintaquadringentillion"
              , "quingentillion"
              , "deciquingentillion"
              , "vigintiquingentillion"
              , "trigintaquingentillion"
              , "quadragintaquingentillion"
              , "quinquagintaquingentillion"
              , "sexagintaquingentillion"
              , "septuagintaquingentillion"
              , "octogintaquingentillion"
              , "nonagintaquingentillion"
              , "sescentillion"
              , "decisescentillion"
              , "vigintisescentillion"
              , "trigintasescentillion"
              , "quadragintasescentillion"
              , "quinquagintasescentillion"
              , "sexagintasescentillion"
              , "septuagintasescentillion"
              , "octogintasescentillion"
              , "nonagintasescentillion"
              , "septingentillion"
              , "deciseptingentillion"
              , "vigintiseptingentillion"
              , "trigintaseptingentillion"
              , "quadragintaseptingentillion"
              , "quinquagintaseptingentillion"
              , "sexagintaseptingentillion"
              , "septuagintaseptingentillion"
              , "octogintaseptingentillion"
              , "nonagintaseptingentillion"
              , "octingentillion"
              , "decioctingentillion"
              , "vigintioctingentillion"
              , "trigintaoctingentillion"
              , "quadragintaoctingentillion"
              , "quinquagintaoctingentillion"
              , "sexagintaoctingentillion"
              , "septuagintaoctingentillion"
              , "octogintaoctingentillion"
              , "nonagintaoctingentillion"
              , "nongentillion"
              , "decinongentillion"
              , "vigintinongentillion"
              , "trigintanongentillion"
              , "quadragintanongentillion"
              , "quinquagintanongentillion"
              , "sexagintanongentillion"
              , "septuagintanongentillion"
              , "octogintanongentillion"
              , "nonagintanongentillion"
              ]
        in [
             ""
           , "thousand"
           , "million"
           , "billion"
           , "trillion"
           , "quadrillion"
           , "quintillion"
           , "sextillion"
           , "septillion"
           , "octillion"
           , "nonillion"
           , "decillion"
           , "undecillion"
           , "duodecillion"
           , "tredecillion"
           , "quattuordecillion"
           , "quindecillion"
           , "sexdecillion"
           , "septendecillion"
           , "octodecillion"
           , "novemdecillion"
           ] ++ liftA2 ((++) =<<) preillion postillion

      illionate =
        let space "" =
              ""
            space x =
              ' ' : x
            todigits acc _ [] =
              acc
            todigits _ [] _ =
              error "unsupported illion"
            todigits acc (_:is) (Zero:Zero:Zero:t) =
              todigits acc is t
            todigits acc (i:is) (q:r:s:t) =
              todigits ((show (D3 s r q) ++ space i) : acc) is t
            todigits acc (_:is) (Zero:Zero:t) =
              todigits acc is t
            todigits acc (i:_) (r:s:_) =
              (show (D2 s r) ++ space i) : acc
            todigits acc (_:is) (Zero:t) =
              todigits acc is t
            todigits acc (i:_) (s:_) =
              (show (D1 s) ++ space i) : acc
        in unwords . todigits [] illion
      toDot =
        let toDot' x [] =
              (x, [])
            toDot' x (h:t) =
              let move = case fromChar h of
                           Just n -> toDot' . (:) n
                           Nothing -> if h == '.'
                                        then
                                          (,)
                                        else
                                           toDot'
              in move x t
        in toDot' []
  in d' ++ " and " ++ c'

-- A data type representing the digits zero to nine.
data Digit =
  Zero
  | One
  | Two
  | Three
  | Four
  | Five
  | Six
  | Seven
  | Eight
  | Nine
  deriving (Show, Eq, Enum, Bounded)

data Digit3 =
  D1 Digit
  | D2 Digit Digit
  | D3 Digit Digit Digit
  deriving Eq

instance Show Digit3 where
  show d =
    let showd x = toLower `fmap` show x
        x .++. y = x ++ if y == Zero then [] else '-' : showd y
    in case d of
        D1 a -> showd a
        D2 Zero b -> showd b
        D2 One b -> case b of
                      Zero -> "ten"
                      One -> "eleven"
                      Two -> "twelve"
                      Three -> "thirteen"
                      Four -> "fourteen"
                      Five -> "fifteen"
                      Six -> "sixteen"
                      Seven -> "seventeen"
                      Eight -> "eighteen"
                      Nine -> "nineteen"
        D2 Two b -> "twenty" .++. b
        D2 Three b -> "thirty" .++. b
        D2 Four b -> "forty" .++. b
        D2 Five b -> "fifty" .++. b
        D2 Six b -> "sixty" .++. b
        D2 Seven b -> "seventy" .++. b
        D2 Eight b -> "eighty" .++. b
        D2 Nine b -> "ninety" .++. b
        D3 Zero Zero Zero -> ""
        D3 Zero b c -> show (D2 b c)
        D3 a Zero Zero -> showd a ++ " hundred"
        D3 a b c -> showd a ++ " hundred and " ++ show (D2 b c)

---- Support

(<<=) ::
  ([a] -> b)
  -> [a]
  -> [b]
_ <<= [] =
  []
f <<= x@(_:t) =
  f x : f <<= t

infixr 5 <<=

lengthGT ::
  (Num n, Ord n) =>
  n
  -> [a]
  -> Bool
lengthGT n [] = 
  n < 0
lengthGT 0 (_:_) =
  True
lengthGT n (_:t) =
  lengthGT (n-1) t

triangle ::
  Integral a =>
  a
  -> a
triangle q =
  q * (q + 1) `div` 2

factors ::
  Int
  -> [Int]
factors n =
  filter (\x -> n `mod` x == 0) [1..n]
